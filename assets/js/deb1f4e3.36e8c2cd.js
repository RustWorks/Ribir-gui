"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8789],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>k});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=s(n),c=i,k=m["".concat(p,".").concat(c)]||m[c]||u[c]||r;return n?a.createElement(k,o(o({ref:t},d),{},{components:n})):a.createElement(k,o({ref:t},d))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4004:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:1},o="The `widget!` macro",l={unversionedId:"essentials/widget-language",id:"essentials/widget-language",title:"The `widget!` macro",description:"widget! macro is a declarative language to help you to build your declare and reactive UI  quickly and expressively. It allows user interfaces to be described in terms of their visual struct, and almost all its syntaxes are expanded from the syntax of Rusts. So don't worry about the learning curve of this DSL language.",source:"@site/../docs/essentials/widget-language.md",sourceDirName:"essentials",slug:"/essentials/widget-language",permalink:"/docs/essentials/widget-language",draft:!1,editUrl:"https://github.com/RibirX/Ribir/tree/master/website/../docs/essentials/widget-language.md",tags:[],version:"current",lastUpdatedBy:"sologeek",lastUpdatedAt:1674964251,formattedLastUpdatedAt:"Jan 29, 2023",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Essentials",permalink:"/docs/category/essentials"},next:{title:"Understand Ribir",permalink:"/docs/essentials/understand-ribir"}},p={},s=[{value:"Nested struct literal syntax to describe widget hierarchy",id:"nested-struct-literal-syntax-to-describe-widget-hierarchy",level:2},{value:"Use id to access and directly react to the widget modifier.",id:"use-id-to-access-and-directly-react-to-the-widget-modifier",level:2},{value:"Use states to declare more stateful objects.",id:"use-states-to-declare-more-stateful-objects",level:2},{value:"Use <code>DynWidget</code> to declare a dynamic widget hierarchy.",id:"use-dynwidget-to-declare-a-dynamic-widget-hierarchy",level:2},{value:"<code>init</code> and <code>finally</code> block",id:"init-and-finally-block",level:2},{value:"Subscribe <code>tap</code> event in <code>finally</code> block",id:"subscribe-tap-event-in-finally-block",level:3},{value:"use <code>watch</code> and <code>let_watch!</code> to watch expression.",id:"use-watch-and-let_watch-to-watch-expression",level:3},{value:"Access <code>BuildCtx</code> in <code>init</code> block",id:"access-buildctx-in-init-block",level:3},{value:"Animations",id:"animations",level:2}],d={toc:s};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"the-widget-macro"},"The ",(0,i.kt)("inlineCode",{parentName:"h1"},"widget!")," macro"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," macro is a declarative language to help you to build your declare and reactive UI  quickly and expressively. It allows user interfaces to be described in terms of their visual struct, and almost all its syntaxes are expanded from the syntax of Rusts. So don't worry about the learning curve of this DSL language."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," is a macro that returns a widget, so you can use it as an expression anywhere you want."),(0,i.kt)("p",null,"Let's learn its syntax by building a greeting application."),(0,i.kt)("h2",{id:"nested-struct-literal-syntax-to-describe-widget-hierarchy"},"Nested struct literal syntax to describe widget hierarchy"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," macro describe widget use rust struct literal syntax."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:"ignore",ignore:!0},'use ribir::prelude::*;\n\nfn main() {\n  let hi = widget! {\n    Text { text: "Hello world!" }\n  };\n\n  app::run(hi);\n}\n')),(0,i.kt)("p",null,"At first, we import ",(0,i.kt)("inlineCode",{parentName:"p"},"ribir::prelude::*"),", which is the list of essential things that a ",(0,i.kt)("inlineCode",{parentName:"p"},"Ribir")," application needs to use. In the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function, we declare a ",(0,i.kt)("inlineCode",{parentName:"p"},"hi")," widget and use it as a root widget to run an application. If you run ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo run"),", a window with text ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello world!")," will launch."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Text")," is a widget provided by Ribir, which displays simple text. It has two fields: the ",(0,i.kt)("inlineCode",{parentName:"p"},"text")," used to specify what text to display, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," specify the style of the text. At here we only use ",(0,i.kt)("inlineCode",{parentName:"p"},"text"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," will be a default value."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Tips"),(0,i.kt)("p",{parentName:"blockquote"},"Any struct can support declare in ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," if it is derived ",(0,i.kt)("inlineCode",{parentName:"p"},"Declare")," trait. ",(0,i.kt)("inlineCode",{parentName:"p"},"Declare")," provide the default value for the ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),". See more in ",(0,i.kt)("a",{parentName:"p",href:"./"},"How ",(0,i.kt)("inlineCode",{parentName:"a"},"Declare")," trait work [wip] ?"),".")),(0,i.kt)("p",null,"The next step, let it support saying hi to anyone. User enters what the ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," display hello to what. So we need a ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," to accept user enter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'  let hi = widget! {\n    Column {\n      Input { \n        PlaceHolder::new("Enter the name you want to greet.")\n      }\n      Text { text: "Hello world!" }\n    }\n  };\n')),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," user interfaces to be described in terms of their visual hierarchy. The above code declares a ",(0,i.kt)("inlineCode",{parentName:"p"},"Column")," widget has two child ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),". And ",(0,i.kt)("inlineCode",{parentName:"p"},"PlaceHolder")," is the child of ",(0,i.kt)("inlineCode",{parentName:"p"},"Input"),". The child always nested declared in the parent. Except for struct literal syntax, we allow describing leaf widgets across tuple struct or function call, like ",(0,i.kt)("inlineCode",{parentName:"p"},"PlaceHolder")," in here."),(0,i.kt)("p",null,"For now, we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," to accept user enter and use a ",(0,i.kt)("inlineCode",{parentName:"p"},"Column")," to place the ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," vertically. But the text of ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," still does not change following user entry."),(0,i.kt)("h2",{id:"use-id-to-access-and-directly-react-to-the-widget-modifier"},"Use id to access and directly react to the widget modifier."),(0,i.kt)("p",null,"Every object is declared in ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," can be named by ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," field, and it must be unique in the whole ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," scope. After a widget is named with ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", its ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," can be directly accessed like a smart pointer in ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," or embed ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),". "),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"id")," implicitly describes the relationship between objects. For example, if a field of object initializes with an expression containing ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", that means the field value will react to the modifies of ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," to update."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let hi = widget! {\n  Column {\n    Input {\n      id: input,\n      Placeholder::new("Enter the name you want to greet.")\n    }\n    Text { \n      text: {\n        let value = &*input.text();\n        format!("Hello {value}!")\n      } \n    }\n  }\n};\n')),(0,i.kt)("p",null,"We named the ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),", and used its text to format a new text for ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),". Now, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," will react to user input."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips")),(0,i.kt)("p",{parentName:"blockquote"},"We did not directly format the text in one line like ",(0,i.kt)("inlineCode",{parentName:"p"},'format!("Hello {}!", input.text())'),", that because Ribir will not deep in external macro to analyze, so if we write ",(0,i.kt)("inlineCode",{parentName:"p"},"input.text()")," in a macro, the expression result will not reactive to the modifies of ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),"."),(0,i.kt)("h2",{parentName:"blockquote",id:"built-in-abilities-compose-to-any-widget"},"Built-in abilities compose to any widget.")),(0,i.kt)("p",null,"After these codes work as we expected, let's try to beautify our style."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let hi = widget! {\n  Column {\n    Input {\n      id: input,\n      h_align: HAlign::Center,\n      Placeholder::new("Enter the name you want to greet.")\n    }\n    Text { \n      text: {\n        let value = &*input.text();\n        format!("Hello {value}!")\n      },\n      h_align: HAlign::Center,\n      v_align: VAlign::Center,\n    }\n  }\n};\n')),(0,i.kt)("p",null,"Now, we center ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," horizontally and center the ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," both horizontally and vertically by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"h_align")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v_algin"),"."),(0,i.kt)("p",null,"But wait, where are the ",(0,i.kt)("inlineCode",{parentName:"p"},"h_align")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v_align")," come from? Both ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," did not have these fields. That is because Ribir provides dozens of built-in widgets. The fields and methods of the built-in widgets can directly use like itself fields of any widgets which declare in the ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),", like ",(0,i.kt)("inlineCode",{parentName:"p"},"padding")," ",(0,i.kt)("inlineCode",{parentName:"p"},"margin")," ",(0,i.kt)("inlineCode",{parentName:"p"},"background")," and so on. ","[See the full list of built-in fields][builtin]"," to know what you can use."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips")),(0,i.kt)("p",{parentName:"blockquote"},"Ribir provides some built-in fields to extend the struct literal syntax. But remember ",(0,i.kt)("strong",{parentName:"p"},"widget fields and built-in fields do not belong to the same widget"),". In essence, they work together in a composed way, which means if the user use a built-in field in a widget, the built-in widget composes the widget into a new widget. In this way, any widget gets many abilities from built-in widgets and pays the memory overhead only if the user use it. ")),(0,i.kt)("h2",{id:"use-states-to-declare-more-stateful-objects"},"Use states to declare more stateful objects."),(0,i.kt)("p",null,"This app immediately change the greet text after user entered every char, even if the name is not entered completely. In this section, we'll add a button to let the user manually submit the name after entering finished and count how many people we have already greeted."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let hi = widget! {\n  states { counter: Stateful::new(0) }\n  Column {\n    Row {\n      align_items: Align::Center,\n      Input {\n        id: input,\n        Placeholder::new("Enter the name you want to greet.")\n      }\n      Button {\n        tap: move |_| {\n          let name = &*input.text();\n          greet.text = format!("Hello {name}!").into();\n          input.set_text("");\n          *counter += 1;\n        },\n        ButtonText::new({\n          let counter = counter.to_string();\n          format!("Greet!({counter})")\n        })\n      }\n    }\n    Text { \n      id: greet,\n      text: "Hello world!",\n      h_align: HAlign::Center,\n      v_align: VAlign::Center,\n    }\n  }\n};\n')),(0,i.kt)("p",null,"The most important change is we add ",(0,i.kt)("inlineCode",{parentName:"p"},"states { counter: Stateful::new(0) }")," before all. We call it ",(0,i.kt)("inlineCode",{parentName:"p"},"states")," block. It starts with a keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"states")," and declare a stateful object in a ",(0,i.kt)("inlineCode",{parentName:"p"},"key: value")," mode. When the stateful object is declared in this block modifier, it'll also be react by others that used it in the ",(0,i.kt)("inlineCode",{parentName:"p"},"widget")," macro, have same behavior like an object named by ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),"."),(0,i.kt)("p",null,"The other change is we add ",(0,i.kt)("inlineCode",{parentName:"p"},"Button")," after the ",(0,i.kt)("inlineCode",{parentName:"p"},"Input"),", and update the ",(0,i.kt)("inlineCode",{parentName:"p"},"Input"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," , and ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," when the user tapped it."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"states")," block it is very useful to tell ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," macro we have other stateful objects that need to be reactive. Here, we defined a stateful object ",(0,i.kt)("inlineCode",{parentName:"p"},"counter"),"and used it as a part text of ",(0,i.kt)("inlineCode",{parentName:"p"},"Button"),". We declare the counter as stateful, so when we modified the ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," after the user tapped the button, the button text will auto-update."),(0,i.kt)("h2",{id:"use-dynwidget-to-declare-a-dynamic-widget-hierarchy"},"Use ",(0,i.kt)("inlineCode",{parentName:"h2"},"DynWidget")," to declare a dynamic widget hierarchy."),(0,i.kt)("p",null,'You may have found that our application has static widget tree, and even if user not enter anything, a "Hello world!" was displayed. In this section, we\'ll introduce a special widget ',(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget")," and use it to generate the ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," widget conditionally."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget")," has a ",(0,i.kt)("inlineCode",{parentName:"p"},"dyns")," field to accept dynamic widgets, ",(0,i.kt)("inlineCode",{parentName:"p"},"dyns")," value will replace ",(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget")," self as its parent children. When ",(0,i.kt)("inlineCode",{parentName:"p"},"dyns")," was modified, the widgets were updated. The ",(0,i.kt)("inlineCode",{parentName:"p"},"dyns")," value type is limited by ",(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget"),"'s parent, usually it can be three kinds:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The child type of ",(0,i.kt)("inlineCode",{parentName:"li"},"DynWidget"),"'s parent want. "),(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("inlineCode",{parentName:"li"},"Option")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"C"),", if ",(0,i.kt)("inlineCode",{parentName:"li"},"DynWidget"),"'s parent accepts one or multi ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," as its child."),(0,i.kt)("li",{parentName:"ul"},"A type that implemented ",(0,i.kt)("inlineCode",{parentName:"li"},"IntoIterator")," and its iterate item is ",(0,i.kt)("inlineCode",{parentName:"li"},"C"),", if ",(0,i.kt)("inlineCode",{parentName:"li"},"DynWidget"),"'s parent accepts  multi ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," as its children.")),(0,i.kt)("p",null,"Now, we use ",(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget")," to control if we need a greet ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'DynWidget {\n  dyns: (*counter > 0).then(|| {\n    widget! {\n      Text { \n        id: greet,\n        text: "Hello world!",\n        h_align: HAlign::Center,\n        v_align: VAlign::Center,\n      }\n    }\n  })\n}\n')),(0,i.kt)("p",null,"This ",(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget")," generates an optional widget to detect if the ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," is greater than zero. "),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips")),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget")," also supports accepting children depending on the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"dyns")," allow.  Its children are static. The dynamic part only limits in ",(0,i.kt)("inlineCode",{parentName:"p"},"dyns")," field."),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"Column {\n DynWidget {\n   dyns: (*counter > 0)\n     // this `Row` is dynamic.\n     .then(||Row::default())\n   // this `Row` is always exist.\n   // if the 'dynamic' Row is Some-value, this `Row` is the child of it. \n   // otherwise, it's the child of the `Column`\n   Row {}\n }\n}\n"))),(0,i.kt)("p",null,"Let's put all code together:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use ribir::prelude::*;\n\nfn main() {\n  let hi = widget! {\n    states { counter: Stateful::new(0) }\n    Column {\n      Row {\n        align_items: Align::Center,\n        Input {\n          id: input,\n          Placeholder::new("Enter the name you want to greet.")\n        }\n        Button {\n          tap: move |_| {\n            let name = &*input.text();\n            greet.text = format!("Hello {name}!").into();\n            input.set_text("");\n            *counter += 1;\n          },\n          ButtonText::new({\n            let counter = counter.to_string();\n            format!("Greet!({counter})")\n          })\n        }\n      }\n\n      DynWidget {\n        dyns: (*counter > 0).then(|| {\n          widget! {\n            Text {\n              id: greet,\n              text: "Hello world!",\n              h_align: HAlign::Center,\n              v_align: VAlign::Center,\n            }\n          }\n        })\n      }\n    }\n  };\n\n  app::run(hi);\n}\n')),(0,i.kt)("p",null,"When we compiled, the compiler complained not find ",(0,i.kt)("inlineCode",{parentName:"p"},"greet"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'error[E0425]: cannot find value `greet` in this scope\n  --\x3e ribir/examples/greet.rs:16:13\n   |\n16 |  greet.text = format!("Hello {name}!").into();\n   |  ^^^^^ not found in this scope\n')),(0,i.kt)("p",null,"That is because the ",(0,i.kt)("inlineCode",{parentName:"p"},"tap")," callback of ",(0,i.kt)("inlineCode",{parentName:"p"},"Button")," is trying to access ",(0,i.kt)("inlineCode",{parentName:"p"},"greet"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," declare in an embed ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," can access any ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," in the same ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," scope or outside ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),", but not allow the embed ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),". In this case, when we think deeply, we'll find ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," does not always exists for the outside ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," scope."),(0,i.kt)("p",null,"In the next section, we'll resolve it across thet access ",(0,i.kt)("inlineCode",{parentName:"p"},"Button")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," in the embed ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," instead of access ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text in the outside ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),"."),(0,i.kt)("h2",{id:"init-and-finally-block"},(0,i.kt)("inlineCode",{parentName:"h2"},"init")," and ",(0,i.kt)("inlineCode",{parentName:"h2"},"finally")," block"),(0,i.kt)("p",null,"As before, we introduced ",(0,i.kt)("inlineCode",{parentName:"p"},"states")," block to declare more stateful objects. There are two other blocks we can use in ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),", that ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"finally")," block."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"init")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"finally")," are blocks only accept statements and run these statements in ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"init")," run statements after the ",(0,i.kt)("inlineCode",{parentName:"p"},"states")," block and before any others in ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),", and the variable in ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," block can be accessed in the whole ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," scope except for ",(0,i.kt)("inlineCode",{parentName:"p"},"states"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"finally")," run statements after everything declare in ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," scope but before ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," compose the final widget to return."),(0,i.kt)("h3",{id:"subscribe-tap-event-in-finally-block"},"Subscribe ",(0,i.kt)("inlineCode",{parentName:"h3"},"tap")," event in ",(0,i.kt)("inlineCode",{parentName:"h3"},"finally")," block"),(0,i.kt)("p",null,"Back to our greet app, first, we update the ",(0,i.kt)("inlineCode",{parentName:"p"},"tap")," callback and only use it to update the ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," and give a name ",(0,i.kt)("inlineCode",{parentName:"p"},"submit")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Button"),", so we can access it in the embed ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'Button {\n  id: submit,\n  tap: move |_| *counter += 1,\n  ButtonText::new({\n    let counter = counter.to_string();\n    format!("Greet!({counter})")\n  })\n}\n')),(0,i.kt)("p",null,"Then we add ",(0,i.kt)("inlineCode",{parentName:"p"},"finally")," block in the embed ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),", and subscribe to the tap stream of ",(0,i.kt)("inlineCode",{parentName:"p"},"submit")," to update the ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text and reset the ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'finally {\n  let guard = submit\n    .tap_stream()\n    .subscribe(move |_| {\n      let name = &*input.text();\n      greet.text = format!("Hello {name}!").into();\n      input.set_text("");\n    })\n    .unsubscribe_when_dropped();\n  move_to_widget!(guard);\n}\n')),(0,i.kt)("p",null,"Let\u2019s review this ",(0,i.kt)("inlineCode",{parentName:"p"},"finally")," block in detail."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"finally")," is the keyword of the block, all statements wrapped by ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," it as part of the block."),(0,i.kt)("p",null,"In this block, there are two statements. Let deep in one by one."),(0,i.kt)("p",null,"In the first statement, ",(0,i.kt)("inlineCode",{parentName:"p"},"submit.tap_stream()")," return the tap event as a ReactiveX ",(0,i.kt)("inlineCode",{parentName:"p"},"Observable")," stream, then we subscribe it to update ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text and reset ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),". The name of ",(0,i.kt)("inlineCode",{parentName:"p"},"unsubscribe_when_dropped")," is self-described, it converts the handle to a variable that will make auto ",(0,i.kt)("inlineCode",{parentName:"p"},"unsubscribe")," when it dropped. So the whole statement subscribes to the tap event of ",(0,i.kt)("inlineCode",{parentName:"p"},"submit")," and create a variable to manage the subscribe lifetime."),(0,i.kt)("p",null,"The next statement ",(0,i.kt)("inlineCode",{parentName:"p"},"move_to_widget!(guard);")," is very simple. ",(0,i.kt)("inlineCode",{parentName:"p"},"move_to_widget!")," move ",(0,i.kt)("inlineCode",{parentName:"p"},"guard")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),", in other words, transfer the ownership of the ",(0,i.kt)("inlineCode",{parentName:"p"},"guard"),". So the ",(0,i.kt)("inlineCode",{parentName:"p"},"guard")," will live as long as ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),", at here it's the ",(0,i.kt)("inlineCode",{parentName:"p"},"greet"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips")),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"ReactiveX is an API for asynchronous programming with observable streams. ",(0,i.kt)("a",{parentName:"li",href:"https://reactivex.io"},"See More")),(0,i.kt)("li",{parentName:"ul"},"rxRust is the implementation of ReactiveX Ribir used. ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rxRust/rxRust"},"See More")))),(0,i.kt)("h3",{id:"use-watch-and-let_watch-to-watch-expression"},"use ",(0,i.kt)("inlineCode",{parentName:"h3"},"watch")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"let_watch!")," to watch expression."),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"finally")," block, we subscribe to the ",(0,i.kt)("inlineCode",{parentName:"p"},"tap")," event stream. Here we provide another way to do the same thing. And we will introduce ",(0,i.kt)("inlineCode",{parentName:"p"},"watch!")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"let_watch!")," macro. They're very useful macros that let we can subscribe to the modifications of an expression result."),(0,i.kt)("p",null,"We already have a stateful object ",(0,i.kt)("inlineCode",{parentName:"p"},"counter"),", and it increments itself after every tap of ",(0,i.kt)("inlineCode",{parentName:"p"},"submit")," button. So we can update the ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text after the ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," modifies. We'll use ",(0,i.kt)("inlineCode",{parentName:"p"},"watch!")," macro to do it. ",(0,i.kt)("inlineCode",{parentName:"p"},"watch!")," helps us to convert an expression to a value stream."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Tips"),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"watch!")," macro subscribe all stateful objects in the expression and recalculates it when any stateful object modifies. ")),(0,i.kt)("p",null,"We use ",(0,i.kt)("inlineCode",{parentName:"p"},"watch!(counter)")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"submit.tap_stream()")," now."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'finally {\n  let guard = watch!(counter)\n    .subscribe(move |_| {\n      let name = &*input.text();\n      greet.text = format!("Hello {name}!").into();\n      input.set_text("");\n    })\n    .unsubscribe_when_dropped();\n  move_to_widget!(guard);\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"let_watch!")," is a more convenient macro if you want to subscribe an expression. Like ",(0,i.kt)("inlineCode",{parentName:"p"},"watch!"),", it converts an expression to a value stream, but also auto unsubscribe this when the root of ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!")," over. We use ",(0,i.kt)("inlineCode",{parentName:"p"},"let_watch!")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"watch!"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".unsubscribe_when_dropped()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"move_to_widget!(guard)")," not necessary anymore."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'finally {\n  let_watch!(counter)\n    .subscribe(move |_| {\n      let name = &*input.text();\n      greet.text = format!("Hello {name}!").into();\n      input.set_text("");\n    });\n}\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Tips"),(0,i.kt)("p",{parentName:"blockquote"},"In most cases, ",(0,i.kt)("inlineCode",{parentName:"p"},"let_watch!")," is a more convenient, but ",(0,i.kt)("inlineCode",{parentName:"p"},"watch!")," is more flexible in some complex situations.")),(0,i.kt)("h3",{id:"access-buildctx-in-init-block"},"Access ",(0,i.kt)("inlineCode",{parentName:"h3"},"BuildCtx")," in ",(0,i.kt)("inlineCode",{parentName:"h3"},"init")," block"),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text with a default style. In this section, we'll use larger letters to highlight it. Instead of hard code for greet ",(0,i.kt)("inlineCode",{parentName:"p"},"style"),", we'll use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Theme")," to init it. "),(0,i.kt)("p",null,"First, let's add an ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," block after ",(0,i.kt)("inlineCode",{parentName:"p"},"states")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"init ctx => {\n  let style = TypographyTheme::of(ctx).headline1.text.clone();\n}\n\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"init")," block has the same syntax as ",(0,i.kt)("inlineCode",{parentName:"p"},"finally"),", but the above code has a little more stuff (",(0,i.kt)("inlineCode",{parentName:"p"},"ctx =>"),") than what the ",(0,i.kt)("inlineCode",{parentName:"p"},"finally")," block we used before."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ctx =>")," is a syntax we use to name ",(0,i.kt)("inlineCode",{parentName:"p"},"BuildCtx"),". Here, ",(0,i.kt)("inlineCode",{parentName:"p"},"ctx")," is the name of ",(0,i.kt)("inlineCode",{parentName:"p"},"BuildCtx"),". Because the ",(0,i.kt)("inlineCode",{parentName:"p"},"finally")," block not use ",(0,i.kt)("inlineCode",{parentName:"p"},"BuildCtx"),", so it be omitted. Let deep into the body, we create a style variable, and init it by the predefined theme."),(0,i.kt)("p",null,"Second, we use ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," to init the ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'Text { \n  id: greet,\n  text: "Hello world!",\n  style,  // new line.\n  h_align: HAlign::Center,\n  v_align: VAlign::Center,\n}\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips")),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TypographyTheme")," configures the text style used in the application as a part of ",(0,i.kt)("inlineCode",{parentName:"li"},"Theme"),". Click [",(0,i.kt)("inlineCode",{parentName:"li"},"Introduction to Theme[wip]"),"] to learn more."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"BuildCtx")," provides many contexts for the application of the ",(0,i.kt)("inlineCode",{parentName:"li"},"widget!"),"."))),(0,i.kt)("h2",{id:"animations"},"Animations"),(0,i.kt)("p",null,"We build a greet application, but the greet text transition without animation looks blunt. In this section, we will add animations to transition the greet text and cover the basic knowledge of Ribir animations."),(0,i.kt)("p",null,"At first, we need to split ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," as three ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),", because the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," part will never change. Our animation only works on the name part."),(0,i.kt)("p",null,"We change the single ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'Text { \n  id: greet,\n  text: "Hello world!",\n  style,\n  h_align: HAlign::Center,\n  v_align: VAlign::Center,\n}\n')),(0,i.kt)("p",null,"To a ",(0,i.kt)("inlineCode",{parentName:"p"},"Row")," widget with three ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),", and apply ",(0,i.kt)("inlineCode",{parentName:"p"},"h_align")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v_align")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Row"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'Row {\n  h_align: HAlign::Center,\n  v_align: VAlign::Center,\n  Text { text: "Hello ", style: style.clone() }\n  Text {\n    id: greet,\n    text: "World",\n    style: style.clone()\n  }\n  Text { text: "!" , style }\n}\n')),(0,i.kt)("p",null,"Then, we can directly update the ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text by the text of ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'finally {\n  let_watch!(counter)\n    .subscribe(move |_| {\n      greet.text = input.text();\n      input.set_text("");\n    });\n}\n')),(0,i.kt)("p",null,'After the widgets are ready, we will add a "ease in" animation to transition ',(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text change. Ribir does animate all across the ",(0,i.kt)("inlineCode",{parentName:"p"},"Animate")," object. Let's declare an ",(0,i.kt)("inlineCode",{parentName:"p"},"Animate")," object after the ",(0,i.kt)("inlineCode",{parentName:"p"},"Row")," widget."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"Animate {\n  id: greet_new,\n  transition: Translation {\n    delay: None,\n    duration: Duration::from_mills(200),\n    easing: easing::EASE_IN,\n    repeat: None,\n  },\n  prop: prop!(greet.transform),\n  from: Transform::translation(0., greet.layout_height() * 2.)\n}\n")),(0,i.kt)("p",null,"We have already introduced ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," before. Here, we use it to name the object ",(0,i.kt)("inlineCode",{parentName:"p"},"greet_new"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Animate")," has three public fields ",(0,i.kt)("inlineCode",{parentName:"p"},"transition"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"prop")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"from"),". These three fields described how an animation runs. "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"transition")," field accepts a type that implemented ",(0,i.kt)("inlineCode",{parentName:"p"},"Roc")," (Rate of change) trait, Ribir provides ",(0,i.kt)("inlineCode",{parentName:"p"},"Transition")," as the standard implementation. We use ",(0,i.kt)("inlineCode",{parentName:"p"},"Transition")," to describe how property animates smoothly from another value to the current value over time. "),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips")),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"Transition")," also supports declaring individual, ",(0,i.kt)("inlineCode",{parentName:"p"},"Animate")," can use it across its ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),"."),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"Transition {\n  id: ease_in,\n  duration: Duration::from_mills(200),\n  easing: easing::EASE_IN,  \n}\nAnimate {\n id: greet_new,\n transition: ease_in.clone_stateful(),\n prop: prop!(greet.transform),\n from: Transform::translation(0., greet.layout_height() * 2.)\n}\n")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"prop")," field accepts the animate property need transition, the animate property is a type that implemented ",(0,i.kt)("inlineCode",{parentName:"p"},"AnimateProperty"),". Here we want to do animate for ",(0,i.kt)("inlineCode",{parentName:"p"},"transform")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"greet"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"prop!(greet.transform)")," help us to construct an animate property by a chaining path of field, and the path must start with a stateful object."))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips")),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transform")," is a built-in field, so we can directly use it even if it's not a field of ",(0,i.kt)("inlineCode",{parentName:"li"},"Text"),"."),(0,i.kt)("li",{parentName:"ul"},"In fact, ",(0,i.kt)("inlineCode",{parentName:"li"},"prop!")," also has a second argument called lerp function. Lerp function requires to implement ",(0,i.kt)("inlineCode",{parentName:"li"},"Fn(&P, &P, f32) -> P"),", it used to interpolate between two property value linearly. If we provide a lerp function argument, that means this property should use this function to calculate interpolate value. Otherwise, the type of property must implement ",(0,i.kt)("inlineCode",{parentName:"li"},"Lerp"),". So we can write the property as")),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// Do same thing as `prop!(greet.transform)`.\nprop!(greet.transform, |from, to, rate| from.lerp(to, rate))\n")),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"We also can use tuple to group multi property. For example ")),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:"ignore",ignore:!0},"Animate {\n  transition: ..,\n  prop: (\n    prop!(greet.transform), \n    prop!(greet.opacity),\n  ), \n  from: (Transition::scale(0., 0.), 0.)\n}\n\n"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"from")," field accept a value of a property which the animate start from.")),(0,i.kt)("p",null,"Someone may need clarification, we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," field describe animate come from, but why not have a ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," field describe where to go. In Ribir, animations are only visual effects and should not affect any application data. Ribir animate always finished at the value of the animate property, that's where the animation goes."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Tips"),(0,i.kt)("p",{parentName:"blockquote"},"Because animations are only visual effects, the animate property must be a field of ",(0,i.kt)("inlineCode",{parentName:"p"},"Render")," widget.")),(0,i.kt)("p",null,"We have learned how to declare an ",(0,i.kt)("inlineCode",{parentName:"p"},"Animate")," object. The next step is to trigger it. We need to trigger it when the ",(0,i.kt)("inlineCode",{parentName:"p"},"greet")," text is modified, so add this statement to ",(0,i.kt)("inlineCode",{parentName:"p"},"finally")," block."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"let_watch!(greet.text)\n  .subscribe(move |_| greet_enter.run());\n")),(0,i.kt)("p",null,"The animation work as we expected now. In practice, we use the predefined ",(0,i.kt)("inlineCode",{parentName:"p"},"Transition")," in theme. We polish over animate code."),(0,i.kt)("p",null,"Add a ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," block, before ",(0,i.kt)("inlineCode",{parentName:"p"},"Row")," widget."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"init ctx => {\n  let ease_in = transitions::EASE_IN.of(ctx);\n}\n")),(0,i.kt)("p",null,"Then use ",(0,i.kt)("inlineCode",{parentName:"p"},"ease_in")," to initialize the ",(0,i.kt)("inlineCode",{parentName:"p"},"Animate"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Animate {\n  id: greet_new,\n  transition: ease_in,\n  prop: prop!(greet.transform),\n  from: Transform::translation(0., greet.layout_height() * 2.)\n}\n")),(0,i.kt)("p",null,"Let's review all the code of the widget."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},' let hi = widget! {\n    states { counter: Stateful::new(0) }\n    init ctx => {\n      let style = TypographyTheme::of(ctx).headline1.text.clone();\n    }\n    Column {\n      Row {\n        align_items: Align::Center,\n        Input {\n          id: input,\n          Placeholder::new("Enter the name you want to greet.")\n        }\n        Button {\n          tap: move |_| *counter += 1,\n          ButtonText::new({\n            let counter = counter.to_string();\n            format!("Greet!({counter})")\n          })\n        }\n      }\n      DynWidget {\n        dyns: (*counter > 0).then(|| {\n          widget! {\n            init ctx => {\n              let ease_in = transitions::EASE_IN.of(ctx);\n            }\n            Row {\n              Text { text: "Hello ", style: style.clone() }\n              Text {\n                id: greet,\n                text: "World",\n                style: style.clone()\n              }\n              Text { text: "!" , style }\n            }\n            Animate {\n              id: greet_new,\n              transition: ease_in,\n              prop: prop!(greet.transform),\n              from: Transform::translation(0., greet.layout_height() * 2.)\n            }\n            finally {\n              let_watch!(counter)\n                .subscribe(move |_| {\n                  greet.text = input.text();\n                  input.set_text("");\n                });\n              let_watch!(greet.text)\n                .subscribe(move |_| greet_new.run());\n            }\n          }\n        })\n      }\n    }\n  };\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips")," "),(0,i.kt)("p",{parentName:"blockquote"},'In addition to a "standard" trigger animation that declares an ',(0,i.kt)("inlineCode",{parentName:"p"},"Animate")," and then manually triggers it, there is a syntax sugar to quick transition property change. It starts with a keyword  ",(0,i.kt)("inlineCode",{parentName:"p"},"transition"),". It gives an animate effect when its value changes."),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:"ignore",ignore:!0},"transition prop!(greet.background) {\n duration: Duration::from_mills(200),\n easing: easing::EASE_IN,\n}\n")),(0,i.kt)("p",{parentName:"blockquote"},"The animate property follows the ",(0,i.kt)("inlineCode",{parentName:"p"},"transition")," keyword, and the next block declares a ",(0,i.kt)("inlineCode",{parentName:"p"},"Transition")," object."),(0,i.kt)("p",{parentName:"blockquote"},"Instead of declaring a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Transition")," object, we also can use ",(0,i.kt)("inlineCode",{parentName:"p"},"by")," field to provide a ",(0,i.kt)("inlineCode",{parentName:"p"},"Transition")," object by an expression."),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:"ignore",ignore:!0},"transition prop!(greet.background) {\n // assume `ease_in` is a `Transition` variable.\n by: ease_in\n}\n"))),(0,i.kt)("p",null,"That's all, we've covered all the syntax of ",(0,i.kt)("inlineCode",{parentName:"p"},"widget!"),"."))}m.isMDXComponent=!0}}]);