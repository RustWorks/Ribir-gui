"use strict";(self.webpackChunkribir_website=self.webpackChunkribir_website||[]).push([[574],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),c=d(n),m=i,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||o;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[c]="string"==typeof e?e:i,s[1]=r;for(var d=2;d<o;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6337:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:1},s="How to build a Todo Application with Ribir",r={unversionedId:"project_practice/how_to_build_a_todo_application_with_ribir",id:"project_practice/how_to_build_a_todo_application_with_ribir",title:"How to build a Todo Application with Ribir",description:"In this tutorial, We'll start learning how to build a Todo application using Ribir. By following this tutorial in its entirety, you will be able to complete a Todo application like this by yourself:",source:"@site/../docs/project_practice/how_to_build_a_todo_application_with_ribir.md",sourceDirName:"project_practice",slug:"/project_practice/how_to_build_a_todo_application_with_ribir",permalink:"/docs/project_practice/how_to_build_a_todo_application_with_ribir",draft:!1,editUrl:"https://github.com/RibirX/Ribir/tree/master/website/../docs/project_practice/how_to_build_a_todo_application_with_ribir.md",tags:[],version:"current",lastUpdatedBy:"sologeek",lastUpdatedAt:1676366933,formattedLastUpdatedAt:"Feb 14, 2023",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Project Practice",permalink:"/docs/category/project-practice"},next:{title:"More Example",permalink:"/docs/project_practice/more_example"}},l={},d=[{value:"Define the Application data structure",id:"define-the-application-data-structure",level:2},{value:"Build the base view using Ribir",id:"build-the-base-view-using-ribir",level:2},{value:"Combine data and view",id:"combine-data-and-view",level:2},{value:"Add and delete task",id:"add-and-delete-task",level:2},{value:"Use <code>Tab</code> to categorize tasks",id:"use-tab-to-categorize-tasks",level:2},{value:"Use <code>Scrollbar</code> to support scrollable",id:"use-scrollbar-to-support-scrollable",level:2},{value:"Adding transition animation",id:"adding-transition-animation",level:2}],p={toc:d};function c(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-to-build-a-todo-application-with-ribir"},"How to build a Todo Application with Ribir"),(0,i.kt)("p",null,"In this tutorial, We'll start learning how to build a Todo application using Ribir. By following this tutorial in its entirety, you will be able to complete a Todo application like this by yourself:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"todo example",src:n(1593).Z,width:"300",height:"450"})),(0,i.kt)("p",null,"This will be an exciting journey. Let's go!"),(0,i.kt)("h2",{id:"define-the-application-data-structure"},"Define the Application data structure"),(0,i.kt)("p",null,"The data structure is the core of the application. In Ribir the interface is just the presentation around the data structure, not interfering with the data structure. So we need to define Todo data structure first."),(0,i.kt)("p",null,"Now let's define the simplest Todo application data structure. I call this structure ",(0,i.kt)("inlineCode",{parentName:"p"},"TodoMVP"),". And as a simplest Todo application has a list of what it use to save the collection of todo task at least. In Rust, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"Vec")," structure to describe a list. And then, the list must have many task. A single task needs two fields, ",(0,i.kt)("inlineCode",{parentName:"p"},"done")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"description"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"done")," field use type ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," to describe task whether or not to complete, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"description")," field use type ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," to describe task specific information."),(0,i.kt)("p",null,"We can try to do it in ",(0,i.kt)("inlineCode",{parentName:"p"},"main.rs"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'struct Task {\n  done: bool,\n  description: String,\n}\nstruct TodoMVP {\n  tasks: Vec<Task>,\n}\nfn main() {\n  let todo_data = TodoMVP {\n    tasks: vec![\n      Task {\n        done: false,\n        description: "Complete how to build an application with Ribir".to_string(),\n      }\n    ]\n  };\n}\n')),(0,i.kt)("p",null,"At this point, our basic data structure is built."),(0,i.kt)("h2",{id:"build-the-base-view-using-ribir"},"Build the base view using Ribir"),(0,i.kt)("p",null,"We had a base data structure. Now we try to use Ribir to build the part of Todo interface view. The base Todo application needs to have two features, input and display. In the input part, we can use an ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," widget to describe it what can be used to submit task. And the display part, we can use a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," widget to describe it, what it can be used to browse the task list. We defined a rough idea of what put ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," in the upper of the whole and put ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," in the lower. Like these upper and lower parts, here we can use a ",(0,i.kt)("inlineCode",{parentName:"p"},"Column")," widget layout, which is a base vertical arrangement layout widget."),(0,i.kt)("p",null,"We call Todo to interface it ",(0,i.kt)("inlineCode",{parentName:"p"},"todo_widget"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use ribir::prelude::*;\nfn main() {\n  // ...\n  let todo_widget = widget! {\n    Column {\n      Input { Placeholder::new("What do you want to do?") }\n      Lists {\n        ListItem {\n          Leading {\n            Checkbox { checked: false }\n          }\n          HeadlineText::new("Complete how to build an application with Ribir")\n        }\n      }\n    }\n  };\n  app::run(todo_widget);\n}\n')),(0,i.kt)("p",null,"You can execute it by ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo run"),", you will see a window what it show ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Lists"),"."),(0,i.kt)("h2",{id:"combine-data-and-view"},"Combine data and view"),(0,i.kt)("p",null,"Now we have Todo data and view. How we combine these both? Actually, our data is core, view is just the presentation of data. So we need to modify the view code."),(0,i.kt)("p",null,"Here we need to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Compose")," trait to combine data and view. Let's try use ",(0,i.kt)("inlineCode",{parentName:"p"},"Compose")," to modify the above code case."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// ...\nimpl Compose for TodoMVP {\n  fn compose(this: StateWidget<Self>) -> Widget {\n    widget! {\n      states { this: this.into_stateful() }\n      Column {\n        Input { Placeholder::new("What do you want to do?") }\n        Lists {\n          ListItem {\n            Leading {\n              Checkbox { checked: false }\n            }\n            HeadlineText::new("Complete how to build an application with Ribir")\n          }\n        }\n      }\n    }\n  }\n}\nfn main() {\n  let todo_data = TodoMVP {\n    tasks: vec![\n      Task {\n        done: false,\n        description: "Complete how to build an application with Ribir".to_string(),\n      }\n    ]\n  }.into_stateful();\n  app::run(todo_data.into_widget());\n}\n')),(0,i.kt)("p",null,"And task data is not static. We need to render it dynamically. Here, we need ",(0,i.kt)("inlineCode",{parentName:"p"},"DynWidget")," to represent dynamic widgets."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use ribir::prelude::*;\n#[derive(Clone)]\nstruct Task {\n  done: bool,\n  description: String,\n}\nstruct TodoMVP {\n  tasks: Vec<Task>,\n}\nimpl TodoMVP {\n  fn task(task: Task) -> Widget {\n    widget! {\n      ListItem {\n        Leading {\n          Checkbox { checked: task.done }\n        }\n        HeadlineText::new(task.description.clone())\n      }\n    }\n  }\n}\nimpl Compose for TodoMVP {\n  fn compose(this: StateWidget<Self>) -> Widget {\n    widget! {\n      states { this: this.into_stateful() }\n      Column {\n        Input { Placeholder::new("What do you want to do?") }\n        Lists {\n          DynWidget {\n            dyns: {\n              let tasks = this.tasks.clone();\n              tasks\n                .into_iter()\n                .map(move |task| {\n                  TodoMVP::task(task)\n                })\n            }\n          }\n        }\n      }\n    }\n  }\n}\nfn main() {\n  let todo_data = TodoMVP {\n    tasks: vec![\n      Task {\n        done: false,\n        description: "Complete how to build an application with Ribir".to_string(),\n      }\n    ]\n  }.into_stateful();\n  app::run(todo_data.into_widget());\n}\n')),(0,i.kt)("p",null,"Now we are finished combining the data and views."),(0,i.kt)("h2",{id:"add-and-delete-task"},"Add and delete task"),(0,i.kt)("p",null,"As a Todo application, it needs to have two base abilities: adding and deleting tasks. Let's complete these two ability. We already have ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," but don't submit, so we add a button. ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Button")," use ",(0,i.kt)("inlineCode",{parentName:"p"},"Row")," to layout horizontally. How to submit input content? We need to add submit an event. Usually, we choose ",(0,i.kt)("inlineCode",{parentName:"p"},"tap")," event to trigger submit action."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'widget! {\n  // ...\n  Column {\n    Row {\n      Input {\n        id: input,\n        Placeholder::new("What do you want to do?")\n      }\n      Button {\n        tap: move |_| {\n          let description = input.text().to_string();\n          this.tasks.push(Task {\n            description,\n            done: false,\n          });\n          input.set_text(String::default().into());\n        },\n        ButtonText::new("ADD")\n      }\n    }\n    // ...\n  }\n  // ...\n}\n')),(0,i.kt)("p",null,"And now we can add task to our application. We need to complete the ability to delete tasks. We should have an ",(0,i.kt)("inlineCode",{parentName:"p"},"Icon")," to respond delete events. We will put the icon in ",(0,i.kt)("inlineCode",{parentName:"p"},"ListItem"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"ListItem")," has ",(0,i.kt)("inlineCode",{parentName:"p"},"Trailing")," to put ",(0,i.kt)("inlineCode",{parentName:"p"},"Widget")," in the trail of list items."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// ...\nimpl TodoMVP {\n  fn task(this: StateRef<Self>, idx: usize, task: Task) -> Widget {\n    let this = this.clone_stateful();\n    widget! {\n      states { this }\n      ListItem {\n        Leading {\n          Checkbox {\n            id: checkbox,\n            checked: task.done\n          }\n        }\n        HeadlineText::new(task.description.clone())\n        Trailing {\n          Icon {\n            tap: move |_| { this.tasks.remove(idx); },\n            svgs::CLOSE\n          }\n        }\n      }\n      finally {\n        let_watch!(checkbox.checked)\n          .subscribe(move |v| this.silent().tasks[idx].done = v);\n      }\n    }\n  }\n}\n// ...\n")),(0,i.kt)("h2",{id:"use-tab-to-categorize-tasks"},"Use ",(0,i.kt)("inlineCode",{parentName:"h2"},"Tab")," to categorize tasks"),(0,i.kt)("p",null,"Suppose we want to archive task to distinguishing task whether or not done clearly. We can divide three tabs, all, activity, and done. In Ribir, ",(0,i.kt)("inlineCode",{parentName:"p"},"Tab")," widget can help us complete this operation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// ...\nTabs {\n  Tab {\n    TabHeader {\n      Text { text: "ALL" }\n    }\n    TabPane {\n      Lists {\n        DynWidget {\n          dyns: {\n            let tasks = this.tasks.clone();\n            tasks\n              .into_iter()\n              .enumerate()\n              .filter(move |(_, _)| true)\n              .map(move |(idx, task)| {\n                TodoMVP::task(this, idx, task)\n              })\n          }\n        }\n      }\n    }\n  }\n  Tab {\n    TabHeader {\n      Text { text: "ACTIVE" }\n    }\n    TabPane {\n      Lists {\n        DynWidget {\n          dyns: {\n            let tasks = this.tasks.clone();\n            tasks\n              .into_iter()\n              .enumerate()\n              .filter(move |(_, task)| !task.done)\n              .map(move |(idx, task)| {\n                TodoMVP::task(this, idx, task)\n              })\n          }\n        }\n      }\n    }\n  }\n  Tab {\n    TabHeader {\n      Text { text: "DONE" }\n    }\n    TabPane {\n      Lists {\n        DynWidget {\n          dyns: {\n            let tasks = this.tasks.clone();\n            tasks\n              .into_iter()\n              .enumerate()\n              .filter(move |(_, task)| task.done)\n              .map(move |(idx, task)| {\n                TodoMVP::task(this, idx, task)\n              })\n          }\n        }\n      }\n    }\n  }\n}\n// ...\n')),(0,i.kt)("p",null,"Yeah, we've done it, but there has a problem -- too lengthy. In ",(0,i.kt)("inlineCode",{parentName:"p"},"TabPane"),", most of the logic is repeated. Let's optimize it. We can abstract and create panel logic."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// ...\nimpl TodoMVP {\n  // ...\n  fn pane(this: StateRef<Self>, cond: fn(&Task) -> bool) -> Widget {\n    let this = this.clone_stateful();\n    widget! {\n      states { this }\n      Lists {\n        DynWidget {\n          dyns: {\n            let tasks = this.tasks.clone();\n            tasks\n              .into_iter()\n              .enumerate()\n              .filter(move |(_, task)| cond(task))\n              .map(move |(idx, task)| {\n                TodoMVP::task(this, idx, task)\n              })\n          }\n        }\n      }\n    }\n  }\n}\nTabs {\n  Tab {\n    TabHeader {\n      Text { text: "ALL" }\n    }\n    TabPane {\n      Self::pane(this, |_| true)\n    }\n  }\n  Tab {\n    TabHeader {\n      Text { text: "ACTIVE" }\n    }\n    TabPane {\n      Self::pane(this, |task| !task.done)\n    }\n  }\n  Tab {\n    TabHeader {\n      Text { text: "DONE" }\n    }\n    TabPane {\n      Self::pane(this, |task| task.done)\n    }\n  }\n}\n// ...\n')),(0,i.kt)("p",null,"Now, this code looks much simpler."),(0,i.kt)("h2",{id:"use-scrollbar-to-support-scrollable"},"Use ",(0,i.kt)("inlineCode",{parentName:"h2"},"Scrollbar")," to support scrollable"),(0,i.kt)("p",null,"If we have many tasks in the view, the out of view contents we can't show it, we need a scrollable view to show all tasks. In Ribir, we have a built-in widget ",(0,i.kt)("inlineCode",{parentName:"p"},"Scrollbar"),". Scrollbar has direction, horizontal or vertical. In our case, we need scroll in a vertical direction, so we should use ",(0,i.kt)("inlineCode",{parentName:"p"},"VScrollbar"),"."),(0,i.kt)("p",null,"It's straightforward like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// ...\nimpl TodoMVP {\n  // ...\n  fn pane(this: StateRef<Self>, cond: fn(&Task) -> bool) -> Widget {\n    let this = this.clone_stateful();\n    widget! {\n      states { this }\n      VScrollbar {\n        Lists {\n          DynWidget {\n            dyns: {\n              let tasks = this.tasks.clone();\n              tasks\n                .into_iter()\n                .enumerate()\n                .filter(move |(_, task)| cond(task))\n                .map(move |(idx, task)| {\n                  TodoMVP::task(this, idx, task)\n                })\n            }\n          }\n        }\n      }\n    }\n  }\n}\n// ...\n")),(0,i.kt)("h2",{id:"adding-transition-animation"},"Adding transition animation"),(0,i.kt)("p",null,"The Ribir is a moden GUI library. Let's add some animation to show. We add a task moving show when it is mounted."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"impl TodoMVP {\n  fn task(this: StateRef<Self>, idx: usize, task: Task) -> Widget {\n    let this = this.clone_stateful();\n    widget! {\n      states { this, mount_idx: Stateful::new(0) }\n      ListItem {\n        id: item,\n        transform: Transform::default(),\n        mounted: move |_| {\n          *mount_idx += 1;\n          mount_animate.run()\n        },\n        Leading {\n          Checkbox {\n            id: checkbox,\n            checked: task.done\n          }\n        }\n        HeadlineText::new(task.description.clone())\n        Trailing {\n          Icon {\n            tap: move |_| { this.tasks.remove(idx); },\n            svgs::CLOSE\n          }\n        }\n      }\n      Animate {\n        id: mount_animate,\n        transition: Transition {\n          delay: Some(Duration::from_millis(100).mul_f32((*mount_idx + 1) as f32)),\n          duration: Duration::from_millis(150),\n          easing: easing::EASE_IN,\n          repeat: None,\n        },\n        prop: prop!(item.transform),\n        from: Transform::translation(-400., 0. ),\n      }\n      finally {\n        let_watch!(checkbox.checked)\n          .subscribe(move |v| this.silent().tasks[idx].done = v);\n      }\n    }\n  }\n}\n")),(0,i.kt)("p",null,"We did it \ud83c\udf89"))}c.isMDXComponent=!0},1593:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/todo_example-bd12dae2fd6ac62c24197fcac468d88a.png"}}]);