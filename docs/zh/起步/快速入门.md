# 快速入门

本章节将为你介绍 Ribir 的全部语法和常用的基本概念。

> 你将了解
>
> - 如何创建和组合 widget
> - 如何响应事件并操作数据
> - 如何让 widget 响应数据变更
> - 如何构建动态 widget
> - 如何将自己的数据结构转变为 widget
> - ? 如何对状态转换和分裂，控制视图更新范围

## 什么是 widget

在 Ribir 中，widget 作为核心概念，它是对视图进行描述的基本单元。在形式上它可以是一个按钮，一个文本框，一个列表，一个对话框，甚至是整个应用界面。在代码上，它可以是一个函数，一个闭包或者一个数据对象。Ribir 将能通过 `&BuildCtx` 构建出 `Widget` 的类型叫做 widget。注意 `Widget` 和 widget 的差别，在整个 Ribir 的语境中，widget 是一个泛称，而大写开头的 `Widget` 是一个具体的 widget，也是所有 widget 构建进入视图的通行证。

如果你不是特别理解上面的话，不用在意，因为你完全不需要关注 widget 的构建过程，Ribir 也禁止干涉这个过程。你只需要明白，Ribir 将所有的 widget 分成四类，并为他们自动实现了 widget 的构建。

- 函数 widget
- `Compose` widget
- `Render` widget
- `ComposeChild` widget

在本章节中，我们将会只介绍函数 widget 和 `Compose` widget。因为在大部分场景中这两种 widget 已经足够满足我们的需求了。作为进阶的内容，我们将在后面的章节中介绍 `Render` widget 和 `ComposeChild` widget。

## 函数 widget

任意一个接收 `&BuildCtx` 作为入参并且返回 `Widget` 的函数或闭包都是一个函数 widget。

在没有外部状态依赖的情况下，通过函数来定义 widget 是最简单的一种 方式。在[创建一个应用](./创建一个应用.md)中，我们已经见过一个 `Hello world!` 的函数 widget 了。本节中，我们仍旧通过 `Hello world!` 来详细介绍函数 widget，看看我们之前使用的 `Hello world!` 例子是如何演变而来的。

### 通过函数来定义 widget

我们先来看一个标准的 `Hello world!` 函数 widget 的例子:

```rust
use ribir::prelude::*;

fn hello_world(ctx!(): &BuildCtx) -> Widget {
  rdl!{ Text { text: "Hello World!" } }
    .widget_build(ctx!())
}

fn main() { 
  App::run(hello_world);
}
```

上面的例子中, 定义了一个 `hello_world` 函数作为 widget。

首先，你应该发现了在函数签名中参数声明（`ctx!(): &BuildCtx`）的特别之处，我们用 `ctx!()` 来作为参数名字，而不是直接给一个名字。这是因为下一行的 `rdl!` 宏会用到`&BuildCtx`，而 `rdl!` 作为一个过程宏，并不知道外部环境的 `&BuildCtx` 的名字，所以 Ribir 统一用 `ctx!()` 来作为 `&BuildCtx` 跨宏传递的名字。而 `ctx!()` 的作用只是简单生成一个特殊名字以避免和上下文冲突。

接下来一行 `rdl!{ Text { text: "Hello World!" } }`，通过 `rdl！` 创建了一个内容为 `Hello World!` 的 `Text`。关于 `rdl!` 的细节，你可以先放到一边，我们将在小节 [使用 `rdl!` 创建和嵌套 widget](#使用-rdl-创建和嵌套-widget) 中详细介绍。

最后，将 `Text` 通过 `widget_build` 方法构建成 `Widget`，作为函数的返回值。

### 闭包和 `fn_widget!`

因为 `hello_world` 并没有被其它人调用，所以你可以将它改写成一个闭包:

```rust
use ribir::prelude::*;

fn main() {
  let hello_world = |ctx!()| {
    rdl!{ Text { text: "Hello World!" } }
      .widget_build(ctx!())
  };
  App::run(hello_world);
}
```

对于通过闭包创建函数控件，Ribir 提供了一个 `fn_widget!` 宏来简化这个过程，`fn_widget!` 除了支持我们本章接下来要讲到的两个语法糖 `@` 和 `$` 之外，你可以简单认为它会这样展开代码：

``` rust ignore
move |ctx!(): &BuildCtx| -> Widget {
  {
    // 你的代码
  }
  .widget_build(ctx!())
}
```

使用 `fn_widget!` 改写 `hello_world` 例子:


```rust
use ribir::prelude::*;

fn main() {
  App::run(fn_widget! { 
    rdl!{ Text { text: "Hello World!" } }
  });
}
```

除了没有使用 `@` 以为，这个例子和你在[创建一个应用](./创建一个应用.md)中看到的已经一样了。

## 使用 `rdl!` 创建对象

`rdl` 是  Ribir Declarative Language 的缩写， `rdl!` 宏的目的就是帮助你以声明式的方式来创建对象。

> 注意：`rdl!` 并不关注类型，只在语法层面做处理，所以并不是只有 widget 才可以用它。

### 声名式创建对象

尽管 `rdl!` 支持任意 Rust 表达式，但我们所说的声名式创建对象，特指一种特别的表达式——即结构体字面量。

当你的表达式是一个结构体字面量时， `rdl!` 会通过 `Declare` trait 来创建对象，这就要求你所创建的对象的类型必须继承或实现了 `Declare` trait。

```rust
use ribir::prelude::*;

#[derive(Declare)]
pub struct Counter {
  #[declare(default = 1)]
  count: usize,
}

let _ = rdl!{ Counter { } };
```

上面的例子中，`Counter` 继承了 `Declare`， 并标记 `count` 默认值为 `1`。 所以在 `rdl!` 中，你可以不用给 `count` 赋值，`rdl!` 创建它时会默认赋值为 `1`。`Declare` 还有一些其它的特性，我们暂不在这里展开。

### 表达式创建对象

除了结构体字面量以外的所有表达式，`rdl!` 仅对它做去语法糖处理，其结果仍旧是原表达式的结果。通常，这种写法只在嵌套 widget 中有必要。

到这里，回顾前文的例子

```rust
use ribir::prelude::*;

fn main() {
  App::run(fn_widget! { 
    rdl!{ Text { text: "Hello World!" } }
  });
}
```
相信你应该已经完全理解它了。

## 组合 widget



## @ 语法糖7

## 事件响应

## 状态——可被侦听和共享的数据

## $ 语法糖

## 侦听表达式的变更

## `Pipe` —— 保持对数据的持续响应

## `Compose` widget —— 描述你的数据结构

## ?状态转换和分裂